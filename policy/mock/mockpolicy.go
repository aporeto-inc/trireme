// Code generated by MockGen. DO NOT EDIT.
// Source: policy/interfaces.go

// Package mockpolicy is a generated GoMock package.
package mockpolicy

import (
	reflect "reflect"

	common "github.com/aporeto-inc/trireme-lib/common"
	policy "github.com/aporeto-inc/trireme-lib/policy"
	gomock "github.com/golang/mock/gomock"
)

// MockRuntimeReader is a mock of RuntimeReader interface
// nolint
type MockRuntimeReader struct {
	ctrl     *gomock.Controller
	recorder *MockRuntimeReaderMockRecorder
}

// MockRuntimeReaderMockRecorder is the mock recorder for MockRuntimeReader
// nolint
type MockRuntimeReaderMockRecorder struct {
	mock *MockRuntimeReader
}

// NewMockRuntimeReader creates a new mock instance
// nolint
func NewMockRuntimeReader(ctrl *gomock.Controller) *MockRuntimeReader {
	mock := &MockRuntimeReader{ctrl: ctrl}
	mock.recorder = &MockRuntimeReaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
// nolint
func (m *MockRuntimeReader) EXPECT() *MockRuntimeReaderMockRecorder {
	return m.recorder
}

// Pid mocks base method
// nolint
func (m *MockRuntimeReader) Pid() int {
	ret := m.ctrl.Call(m, "Pid")
	ret0, _ := ret[0].(int)
	return ret0
}

// Pid indicates an expected call of Pid
// nolint
func (mr *MockRuntimeReaderMockRecorder) Pid() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pid", reflect.TypeOf((*MockRuntimeReader)(nil).Pid))
}

// Name mocks base method
// nolint
func (m *MockRuntimeReader) Name() string {
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name
// nolint
func (mr *MockRuntimeReaderMockRecorder) Name() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockRuntimeReader)(nil).Name))
}

// Tag mocks base method
// nolint
func (m *MockRuntimeReader) Tag(arg0 string) (string, bool) {
	ret := m.ctrl.Call(m, "Tag", arg0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// Tag indicates an expected call of Tag
// nolint
func (mr *MockRuntimeReaderMockRecorder) Tag(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tag", reflect.TypeOf((*MockRuntimeReader)(nil).Tag), arg0)
}

// Tags mocks base method
// nolint
func (m *MockRuntimeReader) Tags() *policy.TagStore {
	ret := m.ctrl.Call(m, "Tags")
	ret0, _ := ret[0].(*policy.TagStore)
	return ret0
}

// Tags indicates an expected call of Tags
// nolint
func (mr *MockRuntimeReaderMockRecorder) Tags() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tags", reflect.TypeOf((*MockRuntimeReader)(nil).Tags))
}

// Options mocks base method
// nolint
func (m *MockRuntimeReader) Options() policy.OptionsType {
	ret := m.ctrl.Call(m, "Options")
	ret0, _ := ret[0].(policy.OptionsType)
	return ret0
}

// Options indicates an expected call of Options
// nolint
func (mr *MockRuntimeReaderMockRecorder) Options() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Options", reflect.TypeOf((*MockRuntimeReader)(nil).Options))
}

// IPAddresses mocks base method
// nolint
func (m *MockRuntimeReader) IPAddresses() policy.ExtendedMap {
	ret := m.ctrl.Call(m, "IPAddresses")
	ret0, _ := ret[0].(policy.ExtendedMap)
	return ret0
}

// IPAddresses indicates an expected call of IPAddresses
// nolint
func (mr *MockRuntimeReaderMockRecorder) IPAddresses() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IPAddresses", reflect.TypeOf((*MockRuntimeReader)(nil).IPAddresses))
}

// PUType mocks base method
// nolint
func (m *MockRuntimeReader) PUType() common.PUType {
	ret := m.ctrl.Call(m, "PUType")
	ret0, _ := ret[0].(common.PUType)
	return ret0
}

// PUType indicates an expected call of PUType
// nolint
func (mr *MockRuntimeReaderMockRecorder) PUType() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PUType", reflect.TypeOf((*MockRuntimeReader)(nil).PUType))
}

// MockResolver is a mock of Resolver interface
// nolint
type MockResolver struct {
	ctrl     *gomock.Controller
	recorder *MockResolverMockRecorder
}

// MockResolverMockRecorder is the mock recorder for MockResolver
// nolint
type MockResolverMockRecorder struct {
	mock *MockResolver
}

// NewMockResolver creates a new mock instance
// nolint
func NewMockResolver(ctrl *gomock.Controller) *MockResolver {
	mock := &MockResolver{ctrl: ctrl}
	mock.recorder = &MockResolverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
// nolint
func (m *MockResolver) EXPECT() *MockResolverMockRecorder {
	return m.recorder
}

// CreatePURuntime mocks base method
// nolint
func (m *MockResolver) CreatePURuntime(contextID string, runtime policy.RuntimeReader) error {
	ret := m.ctrl.Call(m, "CreatePURuntime", contextID, runtime)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreatePURuntime indicates an expected call of CreatePURuntime
// nolint
func (mr *MockResolverMockRecorder) CreatePURuntime(contextID, runtime interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePURuntime", reflect.TypeOf((*MockResolver)(nil).CreatePURuntime), contextID, runtime)
}

// HandlePUEvent mocks base method
// nolint
func (m *MockResolver) HandlePUEvent(contextID string, event common.Event) error {
	ret := m.ctrl.Call(m, "HandlePUEvent", contextID, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// HandlePUEvent indicates an expected call of HandlePUEvent
// nolint
func (mr *MockResolverMockRecorder) HandlePUEvent(contextID, event interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandlePUEvent", reflect.TypeOf((*MockResolver)(nil).HandlePUEvent), contextID, event)
}

// HandleSynchronization mocks base method
// nolint
func (m *MockResolver) HandleSynchronization(contextID string, state common.State, runtime policy.RuntimeReader, syncType policy.SynchronizationType) error {
	ret := m.ctrl.Call(m, "HandleSynchronization", contextID, state, runtime, syncType)
	ret0, _ := ret[0].(error)
	return ret0
}

// HandleSynchronization indicates an expected call of HandleSynchronization
// nolint
func (mr *MockResolverMockRecorder) HandleSynchronization(contextID, state, runtime, syncType interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSynchronization", reflect.TypeOf((*MockResolver)(nil).HandleSynchronization), contextID, state, runtime, syncType)
}

// HandleSynchronizationComplete mocks base method
// nolint
func (m *MockResolver) HandleSynchronizationComplete(syncType policy.SynchronizationType) {
	m.ctrl.Call(m, "HandleSynchronizationComplete", syncType)
}

// HandleSynchronizationComplete indicates an expected call of HandleSynchronizationComplete
// nolint
func (mr *MockResolverMockRecorder) HandleSynchronizationComplete(syncType interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleSynchronizationComplete", reflect.TypeOf((*MockResolver)(nil).HandleSynchronizationComplete), syncType)
}
