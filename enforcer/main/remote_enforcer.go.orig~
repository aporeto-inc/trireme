package main

import (
	"crypto/ecdsa"
	"fmt"
	"net"
	"net/http"
	"net/rpc"
	"os"
	"os/signal"
	"bufio"
	"time"
	
	"github.com/aporeto-inc/trireme/collector"
	"github.com/aporeto-inc/trireme/enforcer"
	"github.com/aporeto-inc/trireme/policy"
	"github.com/aporeto-inc/trireme/supervisor"
	//_ "github.com/aporeto-inc/trireme/utils/nsenter"
	"github.com/aporeto-inc/trireme/utils/packet"
	"github.com/aporeto-inc/trireme/utils/rpc_payloads"
	"github.com/aporeto-inc/trireme/utils/tokens"
)

type collectorImpl struct{}

//MsgHandler unexported
type msgHandler struct {
	Enforcer   enforcer.PolicyEnforcer
	Collector  collector.EventCollector
	Supervisor supervisor.Supervisor
}

const (
	ipcProtocol = "unix"
	defaultPath = "/var/run/default.sock"
)

//These are actual implementations which will either push to a channel which do RPC back to trireme
//or we can pull from trireme
func (c *collectorImpl) CollectFlowEvent(contextID string, tags policy.TagsMap, action string, mode string, sourceID string, tcpPacket *packet.Packet) {

}

//This event should not be expected here in the enforcer process inside a particular container context
func (c *collectorImpl) CollectContainerEvent(contextID string, ip string, tags policy.TagsMap, event string) {
}

//ProcessMessage exported
func (m *msgHandler) ProcessMessage(req *rpcWrapper.Request, resp *rpcWrapper.Response) error {
	return nil
}

func (m *msgHandler) Init(req *rpcWrapper.Request, resp *rpcWrapper.Response) error {
	return nil
}

//InitEnforcer exported
func (m *msgHandler) InitEnforcer(req *rpcWrapper.Request, resp *rpcWrapper.Response) error {
	if req.MethodIdentifier != rpcWrapper.InitEnforcer {
		return fmt.Errorf("Payload malformed :: wrong method call")
	}
	collector := new(collectorImpl)
	m.Collector = collector
	payload := req.Payload.(rpcWrapper.InitRequestPayload)
	usePKI := (payload.SecretType == tokens.PKIType)

	if usePKI {
		//PKI params
		publicKeyAdder := tokens.NewPKISecrets(payload.PrivatePEM, payload.PublicPEM, payload.CAPEM, map[string]*ecdsa.PublicKey{})
		m.Enforcer = enforcer.NewDefaultDatapathEnforcer(payload.ContextID, collector, publicKeyAdder)
	} else {
		//PSK params
		publicKeyAdder := tokens.NewPSKSecrets(payload.PublicPEM)
		m.Enforcer = enforcer.NewDefaultDatapathEnforcer(payload.ContextID, collector, publicKeyAdder)
	}

	resp.MethodIdentifier = rpcWrapper.InitEnforcer
	resp.Status = rpcWrapper.SUCCESS
	return nil
}

//InitSupervisor exported
func (m *msgHandler) InitSupervisor(req *rpcWrapper.Request, resp *rpcWrapper.Response) error {
	if req.MethodIdentifier != rpcWrapper.InitSupervisor {
		return fmt.Errorf("Payload malformed :: wrong method call")
	}
	ipt, err := supervisor.NewGoIPTablesProvider()
	payload := req.Payload.(rpcWrapper.InitSupervisorPayload)
	if err != nil {
		fmt.Printf("Failed to load Go-Iptables: %s", err)
		panic("Failed to load Go-Iptables: ")
	}
	m.Supervisor, _ = supervisor.NewIPTablesSupervisor(m.Collector, m.Enforcer, ipt, payload.TargetNetworks)
	return nil
}

//CleanupEnforcer unexported Method for cleanup of resources managed outside enforcer package
func CleanupEnforcer() {
	f,_ := os.Create("/tmp/cleanenforcer")
	f.Close()
}
func main() {
	f,err := os.Create("/tmp/enforcer_log")
	if(err != nil){
		fmt.Println(err)
	}
	
	namedPipe := os.Getenv("SOCKET_PATH")
	w := bufio.NewWriter(f)
	w.WriteString("NamedPIPE" + namedPipe + "\n")
	w.Flush()
	f.Close()
	/*msgHandler := new(msgHandler)
	rpc.RegisterName("Server", msgHandler)
	rpc.HandleHTTP()
	if len(namedPipe) == 0 {
		panic("Sock param not passed in environment")
	}
	listen, err := net.Listen(ipcProtocol, namedPipe)
	
	if err != nil {
		panic(err)
	}
	w.WriteString("\nListen Suceeded\n")
	w.Flush()
	defer listen.Close()
	go http.Serve(listen, nil)*/
	time.Sleep(1000*time.Second)
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	<-c

	_, err = os.Stat(namedPipe)
	if !os.IsNotExist(err) {
		os.Remove(namedPipe)
	}
	CleanupEnforcer()
	os.Exit(0)
}
