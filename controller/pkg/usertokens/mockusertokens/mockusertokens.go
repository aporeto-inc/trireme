// Code generated by MockGen. DO NOT EDIT.
// Source: controller/pkg/usertokens/usertokens.go

// Package mockusertokens is a generated GoMock package.
package mockusertokens

import (
	context "context"
	url "net/url"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	common "go.aporeto.io/enforcerd/trireme-lib/controller/pkg/usertokens/common"
)

// MockVerifier is a mock of Verifier interface
// nolint
type MockVerifier struct {
	ctrl     *gomock.Controller
	recorder *MockVerifierMockRecorder
}

// MockVerifierMockRecorder is the mock recorder for MockVerifier
// nolint
type MockVerifierMockRecorder struct {
	mock *MockVerifier
}

// NewMockVerifier creates a new mock instance
// nolint
func NewMockVerifier(ctrl *gomock.Controller) *MockVerifier {
	mock := &MockVerifier{ctrl: ctrl}
	mock.recorder = &MockVerifierMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
// nolint
func (m *MockVerifier) EXPECT() *MockVerifierMockRecorder {
	return m.recorder
}

// VerifierType mocks base method
// nolint
func (m *MockVerifier) VerifierType() common.JWTType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifierType")
	ret0, _ := ret[0].(common.JWTType)
	return ret0
}

// VerifierType indicates an expected call of VerifierType
// nolint
func (mr *MockVerifierMockRecorder) VerifierType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifierType", reflect.TypeOf((*MockVerifier)(nil).VerifierType))
}

// Validate mocks base method
// nolint
func (m *MockVerifier) Validate(ctx context.Context, token string) ([]string, bool, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate", ctx, token)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// Validate indicates an expected call of Validate
// nolint
func (mr *MockVerifierMockRecorder) Validate(ctx, token interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockVerifier)(nil).Validate), ctx, token)
}

// Callback mocks base method
// nolint
func (m *MockVerifier) Callback(ctx context.Context, u *url.URL) (string, string, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Callback", ctx, u)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(int)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// Callback indicates an expected call of Callback
// nolint
func (mr *MockVerifierMockRecorder) Callback(ctx, u interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Callback", reflect.TypeOf((*MockVerifier)(nil).Callback), ctx, u)
}

// IssueRedirect mocks base method
// nolint
func (m *MockVerifier) IssueRedirect(arg0 string) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IssueRedirect", arg0)
	ret0, _ := ret[0].(string)
	return ret0
}

// IssueRedirect indicates an expected call of IssueRedirect
// nolint
func (mr *MockVerifierMockRecorder) IssueRedirect(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IssueRedirect", reflect.TypeOf((*MockVerifier)(nil).IssueRedirect), arg0)
}
